// GRADLE-2087 workaround, perform after java plugin
status = project.hasProperty('preferredStatus')?project.preferredStatus:(version.contains('SNAPSHOT')?'snapshot':'release')

apply plugin: 'java' // Plugin as major conventions

sourceCompatibility = 1.6
[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

repositories {
    mavenCentral()
}

// Restore status after Java plugin
status = rootProject.status

task sourcesJar(type: Jar, dependsOn:classes) {
    from sourceSets.main.allSource
    classifier 'sources'
    extension 'jar'
}

task javadocJar(type: Jar, dependsOn:javadoc) {
    from javadoc.destinationDir
    classifier 'javadoc'
    extension 'jar'
}

configurations.create('sources')
configurations.create('javadoc')
configurations.archives {
    extendsFrom configurations.sources
    extendsFrom configurations.javadoc
}

artifacts {
    sources(sourcesJar) {
        // Weird Gradle quirk where type will be used for the extension, but only for sources
        type 'jar'
    }
    javadoc(javadocJar) {
        type 'javadoc'
    }
}

configurations {
    provided {
        description = 'much like compile, but indicates you expect the JDK or a container to provide it. It is only available on the compilation classpath, and is not transitive.'
        transitive = true
        visible = true
    }
}

project.sourceSets {
    main.compileClasspath += project.configurations.provided
    main.runtimeClasspath -= project.configurations.provided
    test.compileClasspath += project.configurations.provided
    test.runtimeClasspath += project.configurations.provided
}

tasks.withType(Test) {
    testLogging.showStandardStreams = true

    // listen to events in the test execution lifecycle
    beforeTest { descriptor ->
        logger.lifecycle(":" + descriptor)
    }
}

def docTasks = [:]
[Javadoc,ScalaDoc,Groovydoc].each{ Class docClass ->
    def allSources = allprojects.tasks*.withType(docClass).flatten()*.source
    if (allSources) {
        def shortName = docClass.simpleName.toLowerCase()
        def docTask = task "aggregate${shortName.capitalize()}"(type: docClass, description: "Aggregate subproject ${shortName}s") {
            source = allSources
            doFirst {
                def classpaths = allprojects.findAll { it.plugins.hasPlugin(JavaPlugin) }.collect { it.sourceSets.main.compileClasspath }
                classpath = files(classpaths)
            }
        }
        docTasks[shortName] = docTask
    }
}

task listCache << {
    description = 'Prints all items in all Configurations (extends FileCollection), representing all artifacts and their dependencies.'
    configurations.compile.each { println it }
}

task listJars << {
    description = 'Prints the JAR files from all Configurations.'
    configurations.compile.each { File file -> println file.name }
}

// Generate wrapper, which is distributed as part of source to alleviate the need of installing gradle
task wrapper(type: Wrapper) {
    gradleVersion = '1.6'
}
